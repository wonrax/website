---
layout: "@/layouts/BlogPostLayout.astro"
title: "Dependencies, reproducibility and trust"
description: ""
published: '17 May 2025'
tags:
  - reproducibility
  - rust
isDraft: true
---

Recently [a post](https://vincents.dev/blog/rust-dependencies-scare-me/) blew
up on Hacker News and many more places about Rust dependency hell. The post
just shallowly rants about how many dependencies needed for a simple Rust
project without proposing a solution, so there's not much to say about it.
However it did get me thinking about dependencies in general and how they
relate to reproducibility and trust, and how can we make them better without
giving up on the convenience they provide.

Just complaining without understanding the problem is harmful in my opinion
(people are scared of things they don't understand), and I think it's important
to understand the tradeoffs so that we can make better decisions and set up
guardrails to protect ourselves from the problems that come with them.

[LetsBeRealAboutDependencies](
https://wiki.alopex.li/LetsBeRealAboutDependencies) argues that package manager
and statically linked binaries are improvements upon the old way of doing
things--dynamic linking and shared libraries. However they're aware of the
tradeoffs that come with it. They also do not offer solutions to the problems
they raise, but rather just point them out.

Unfortunately, this post does not offer any solutions either, but rather argues
that package managers are fine, but we need to be aware of the tradeoffs they
bring. And shows what are the ways to address these problems.

Dependencies are not inherent, your project does not depend on some packages
does not mean you don't have dependencies. Your compiler may depend on some
runtime or build time dependencies,...

- Running the “Reflections on Trusting Trust” Compiler:
  >  The programming environments for languages like Go, NPM, and Rust make it
  >  trivial to download and run source code published by strangers on the
  >  internet, and again almost no one is checking the code, until there is a
  >  problem. No one needs Ken’s backdoor: there are far easier ways to mount a
  >  supply chain attack.
  >
  >  On the other hand, given all our reckless behavior, there are far fewer
  >  problems than you would expect. Quite the opposite: we trust computers
  >  with nearly every aspect of our lives, and for the most part nothing bad
  >  happens. Something about our security posture must be better than it
  >  seems. Even so, it might be nicer to live in a world where the only
  >  possible attacks required the sophistication of approaches like Ken’s
  >  (like in this excellent science fiction story).

- Minimize deps, don't use package managers at all, vendor your dependencies
  (JonBlow tweet)
  - This is a good idea, but it doesn't scale well. You end up with a lot of
    code duplication and it's hard to keep track of what you have and what you
    don't have. It's also hard to update dependencies when you need to.
  - When you need to audit your dependencies, it's exponentially harder since
    every package has their own implementation of X. Whereas if you use a
    package manager, multiple packages can share the same implementation of X.

- A mix of trust and verify (you can't verify everything), reduce blast radius
  and attack surface

- Nix

### Trust
We have to trust our dependencies to some extent. Society is built on trust,
and we can't live in a world where we don't trust anything. We trust the
compiler to not have a backdoor, otherwise we'd have to bootstrap our own
compiler. And how do we know that the bootstrapping compiler is also not
compromised? Just like [basic beliefs](https://iep.utm.edu/epi-just), we have
to trust some things without proof otherwise we'll fall into a vicious cycle of
infinite regress or total skepticism.

Depends on the seriousness of what you're building, the level of trust can be
different. Whether you need to assess the trustworthiness by number of GitHub
stars, trusting certified 3rd party audits or or audit the code yourself.

\## TODO reproducibility

### Overcome
For rust and cargo, but might apply to other languages as well:
- cargo-vendor: to not depend on centralized package registries.
- cargo-deny: to ban packages in lockfile that you don't trust.

\## TODO fix the adding comments complexity analysis
