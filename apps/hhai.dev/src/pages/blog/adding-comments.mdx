---
layout: "@/layouts/BlogPostLayout.astro"
title: "Adding comments"
description: "Nerding out on Rust, SQL, and recursive CTE sorting algorithms."
published: "28 October 2023"
updated: "25 Jan 2025"
tags:
  - rust
  - algo
  - sql
---

I wanted to enable discussion on my blog posts but found existing solutions like Disqus and GitHub-based systems lacking in performance, longevity, or user experience. Since I already had a Rust API and PostgreSQL database for tracking views, I decided to build my own comment system. This required solving several challenges:

- Data modeling and API design
- User interface implementation
- Markdown rendering and sanitization
- Spam prevention and moderation

This article focuses on the data modeling process, schema design, and algorithms for efficiently retrieving and sorting nested comment threads.

## Data Modeling

I chose the adjacency list model for storing comments. Each comment references its parent via `parent_id`, with `NULL` indicating a root-level comment. This approach provides flexibility while keeping the schema simple:

```prisma showLineNumbers title="schema.prisma"
model Post {
  id       Int       @id @default(autoincrement())
  category String
  slug     String
  title    String
  comments Comment[]

  @@unique([category, slug])
}

model Comment {
  id           Int      @id @default(autoincrement())
  author_ip    String
  author_name  String
  author_email String?
  content      String
  post_id      Int
  parent_id    Int?
  created_at   DateTime @default(now())
  upvote       Int      @default(0)

  parent   Comment? @relation("ChildComments", fields: [parent_id], references: [id])
  children Comment[] @relation("ChildComments")
  post     Post     @relation(fields: [post_id], references: [id])
}
```

The corresponding SQL migration script creates the necessary tables and relationships:

```sql showLineNumbers title="01_comments.sql"
CREATE TABLE "posts" (
    "id" SERIAL PRIMARY KEY,
    "category" TEXT NOT NULL,
    "slug" TEXT NOT NULL,
    "title" TEXT NOT NULL
);

CREATE TABLE "comments" (
    "id" SERIAL PRIMARY KEY,
    "author_ip" TEXT NOT NULL,
    "author_name" TEXT NOT NULL,
    "author_email" TEXT,
    "content" TEXT NOT NULL,
    "post_id" INTEGER NOT NULL,
    "parent_id" INTEGER,
    "created_at" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "upvote" INTEGER NOT NULL DEFAULT 0
);

CREATE UNIQUE INDEX "posts_category_slug_unique" ON "posts"("category", "slug");

ALTER TABLE "comments"
    ADD CONSTRAINT "comments_parent_id_fkey"
    FOREIGN KEY ("parent_id") REFERENCES "comments"("id") 
    ON DELETE SET NULL ON UPDATE CASCADE;

ALTER TABLE "comments"
    ADD CONSTRAINT "comments_post_id_fkey"
    FOREIGN KEY ("post_id") REFERENCES "posts"("id") 
    ON DELETE RESTRICT ON UPDATE CASCADE;
```

:::tip
While I use Prisma for schema management and migrations, the production API uses Rust's `sqlx` for direct database access without ORM overhead.
:::

## Retrieving and Sorting Comments

We need to retrieve comments hierarchically sorted by votes and timestamp. The SQL query uses a recursive CTE to fetch comments in hierarchical order:

```sql showLineNumbers
WITH RECURSIVE root_comments AS (
    SELECT
        id,
        parent_id,
        author_name,
        content,
        created_at,
        upvote,
        ARRAY[id] AS path,
        0 AS depth
    FROM comments
    JOIN posts ON posts.id = comments.post_id
    WHERE 
        posts.category = 'blog'
        AND posts.slug = $1
        AND parent_id IS NULL
    ORDER BY upvote DESC, created_at
    LIMIT $2 OFFSET $3
), comment_tree AS (
    SELECT * FROM root_comments
    UNION ALL
    SELECT
        c.id,
        c.parent_id,
        c.author_name,
        c.content,
        c.created_at,
        c.upvote,
        t.path || c.id,
        t.depth + 1
    FROM comment_tree t
    JOIN comments c ON c.parent_id = t.id
)
SELECT * FROM comment_tree
ORDER BY path;
```

This query returns comments in depth-first order, with each comment appearing after its parent. The result requires additional processing to sort replies at each level:

| id | parent_id | author | content | path | depth | created_at | upvote |
|----|-----------|--------|---------|------|-------|------------|--------|
| 1  | NULL      | wonrax | 1.      | {1}  | 0     | 2023-10-25 | 0      |
| 2  | 1         | wonrax | 1.1.    | {1,2}| 1     | 2023-10-25 | 0      |
| 3  | 2         | wonrax | 1.1.1.  | {1,2,3}| 2   | 2023-10-26 | 0      |
| 6  | 3         | wonrax | 1.1.1.1.| {1,2,3,6}|3|2023-10-26|0|
| 4  | 1         | wonrax | 1.2.    | {1,4}| 1     | 2023-10-26 | 1      |
| 5  | 1         | wonrax | 1.3.    | {1,5}| 1     | 2023-10-26 | 2      |
| 7  | NULL      | wonrax | 2.      | {7}  | 0     | 2023-10-26 | 0      |
| 8  | 7         | wonrax | 2.1.    | {7,8}| 1     | 2023-10-26 | 0      |

## Sorting Algorithms

### 1. Recursive Iteration Approach

This method processes comments sequentially, grouping children with their parents and recursively sorting each group:

```rust showLineNumbers
fn sort_comments_iterative(comments: Vec<Comment>) -> Vec<Comment> {
    if comments.is_empty() {
        return Vec::new();
    }

    let root_depth = comments[0].depth;
    let mut result = Vec::with_capacity(comments.len());
    let mut children_map = HashMap::new();
    let mut current_root = comments[0].id;

    // Group comments by parent
    for comment in comments {
        if comment.depth == root_depth {
            current_root = comment.id;
            result.push(comment.clone());
            children_map.insert(comment.id, Vec::new());
        } else {
            children_map.get_mut(&current_root).unwrap().push(comment);
        }
    }

    // Sort root comments
    result.sort_unstable_by_key(|c| (-c.upvote, c.created_at));

    // Recursively sort and insert children
    let mut index = 0;
    for root_comment in result.clone() {
        if let Some(children) = children_map.remove(&root_comment.id) {
            let sorted_children = sort_comments_iterative(children);
            let insert_position = index + 1;
            for child in sorted_children {
                result.insert(insert_position, child);
                index += 1;
            }
        }
        index += 1;
    }

    result
}
```

**Complexity Analysis**:
- **Time**: O(n log n) average-case, O(n²) worst-case (unbalanced trees)
- **Space**: O(n) for grouping storage
- **Pros**: Minimal memory overhead for shallow trees
- **Cons**: Performance degrades with deep nesting

### 2. Intermediate Tree Approach

This method builds a tree structure in memory, sorts each node's children, then flattens the tree:

```rust showLineNumbers
struct CommentNode {
    comment: Comment,
    children: Vec<CommentNode>,
}

fn build_comment_tree(comments: Vec<Comment>) -> Vec<CommentNode> {
    let mut node_map: HashMap<i32, CommentNode> = comments
        .into_iter()
        .map(|c| (c.id, CommentNode { comment: c, children: Vec::new() }))
        .collect();

    let mut roots = Vec::new();
    for id in node_map.keys().cloned().collect::<Vec<_>>() {
        if let Some(parent_id) = node_map[&id].comment.parent_id {
            if let Some(parent) = node_map.get_mut(&parent_id) {
                let child = node_map.remove(&id).unwrap();
                parent.children.push(child);
            }
        } else {
            roots.push(node_map.remove(&id).unwrap());
        }
    }
    roots
}

fn sort_comment_tree(nodes: &mut [CommentNode]) {
    nodes.sort_unstable_by_key(|n| (-n.comment.upvote, n.comment.created_at));
    for node in nodes {
        sort_comment_tree(&mut node.children);
    }
}

fn flatten_tree(nodes: Vec<CommentNode>) -> Vec<Comment> {
    let mut result = Vec::new();
    let mut stack = nodes.into_iter().rev().collect::<Vec<_>>();
    
    while let Some(mut node) = stack.pop() {
        let children = std::mem::take(&mut node.children);
        stack.extend(children.into_iter().rev());
        result.push(node.comment);
    }
    result
}
```

**Complexity Analysis**:
- **Time**: O(n log n) - Efficient sorting dominates
- **Space**: O(n) - Linear memory overhead
- **Pros**: Consistent performance regardless of nesting depth
- **Cons**: Slightly higher constant factors from tree construction

## Performance Comparison

Benchmark results demonstrate the intermediate tree method's superiority at scale:

| Comments | Recursive Iteration | Intermediate Tree |
|----------|---------------------|-------------------|
| 10       | **1.37 µs**         | 1.68 µs           |
| 1,000    | 252 µs              | **201 µs**        |
| 10,000   | 3.33 ms             | **1.99 ms**       |
| 100,000  | 61.5 ms             | **27.9 ms**       |

The intermediate tree approach scales better due to its O(n log n) complexity versus the recursive method's worst-case O(n²) performance. While both methods use O(n) space, the tree-based solution maintains consistent performance regardless of comment nesting depth.

## Implementation Insights

The benchmark harness generates synthetic comment trees with configurable depth:

```rust showLineNumbers
fn generate_comments(count: usize, max_depth: usize) -> Vec<Comment> {
    let mut rng = rand::thread_rng();
    let mut comments = Vec::with_capacity(count);
    let mut parent_stack = Vec::new();

    for id in 0..count as i32 {
        let depth = if parent_stack.is_empty() {
            0
        } else {
            rng.gen_range(0..=max_depth.min(parent_stack.len()))
        };

        // Truncate stack to current depth
        parent_stack.truncate(depth);

        let parent_id = parent_stack.last().copied();

        comments.push(Comment {
            id,
            author_name: "Author".into(),
            content: "Content".into(),
            parent_id,
            created_at: Utc::now().naive_utc(),
            upvote: rng.gen_range(0..100),
            depth: depth as i32,
        });

        parent_stack.push(id);
    }
    comments
}
```

Key implementation details:
1. **Tree Construction**: Efficiently builds hierarchy using parent pointers
2. **Non-recursive Sorting**: Iterative flattening avoids recursion limits
3. **In-place Operations**: Minimizes allocations for performance
4. **Depth Control**: Configurable maximum nesting depth

## Conclusion

The intermediate tree method provides the best balance of performance and consistency for sorting hierarchical comments. Its O(n log n) time complexity makes it suitable for large comment threads, while the adjacency list model in PostgreSQL efficiently stores hierarchical relationships.

Future enhancements could include:
- Pagination at multiple tree levels
- Real-time updates via WebSockets
- Collaborative filtering for spam detection
- Personalized comment ranking based on user preferences

By building a custom solution, we achieve better performance, control, and longevity compared to third-party services while maintaining a simple user experience.
