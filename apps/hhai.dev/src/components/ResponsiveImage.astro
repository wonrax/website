---
// An adaption of
// https://gist.github.com/sannajammeh/d1dfddc8c2538062de53714b07953cdf

import type { ImageMetadata, ImageTransform } from "astro";
import { getImage } from "astro:assets";
type Props = {
  src: ImageMetadata | string;
  alt: string;
  width?: number;
  height?: number;
  quality?: number;
  format?: string;
  sizes?: string;
  /**
   * Array of screens to generate the image for i.e [320, 480, 1200]
   * Maximum width will be 1200 regardless if screen is larger
   */
  deviceSizes?: number[];
} & Omit<ImageTransform, "src"> &
  Omit<astroHTML.JSX.ImgHTMLAttributes, "src" | "width" | "height">;
import { ArrowDown } from "lucide-solid";

const {
  src,
  format,
  width: propsWidth,
  height,
  quality,
  alt,
  loading = "lazy",
  decoding = "async",
  sizes,
  deviceSizes = [320, 480, 640, 750, 828, 1200, 1920, 2048, 3840],
  ...rest
} = Astro.props;
if (!src) {
  throw new Error("src is required");
}

const getImageType = () => {
  if (typeof src === "string") {
    // TODO support URL containing query params
    return src.split(".").pop();
  }

  return src.format;
};

let originalWidth;
let originalHeight;

if (typeof src === "string") {
  // Remote image
  originalWidth = propsWidth;
  originalHeight = height;
} else {
  // Local image
  originalWidth = src.width;
  originalHeight = src.height;
}

if (!originalWidth || !originalHeight) {
  throw new Error(
    "couldn't figure out image size, please provide width and height if it's a remote image"
  );
}

const aspectRatio = originalHeight / originalWidth;
// If propsWidth is provided, use it as the maximum size
const maxWidth =
  propsWidth && propsWidth <= originalWidth ? propsWidth : originalWidth;

let sizesAttr = getImageType() === "svg" ? undefined : sizes;
let srcset = undefined;

if (getImageType() !== "svg") {
  // Filter out sizes that are larger than the max width
  const validSizes = deviceSizes.filter((size) => size <= maxWidth);
  const generateSrcSet = async (size: number) => {
    const resizedImg = await getImage({
      src,
      format,
      width: size,
      height: Math.round(size * aspectRatio),
      quality,
    } as ImageTransform);
    return `${resizedImg.src} ${size}w`;
  };
  const srcsetPromises = validSizes.map(generateSrcSet);
  const srcsetResults = await Promise.all(srcsetPromises);
  srcset = srcsetResults.join(", ");

  if (!sizesAttr) {
    const sizesAttrMapped = validSizes
      .map((size) => `(max-width: ${size}px) ${size}px`)
      .join(", ");
    sizesAttr = `
  ${sizesAttrMapped},
  ${maxWidth}px
`;
  }
}

const original = await getImage({
  src,
  format: "png",
  width: maxWidth,
  height: Math.round(maxWidth * aspectRatio),
  quality: 100,
} as ImageTransform);
---

<img
  src={original.src}
  srcset={srcset}
  sizes={sizesAttr}
  alt={alt}
  loading={loading}
  decoding={decoding}
  width={originalWidth}
  height={originalHeight}
  {...rest}
/>
<div class="image-caption">
  <div>
    <slot />
  </div>
  <a
    class="rounded-button"
    href={original.src}
    aria-label={`Download image, ${alt}`}
  >
    <ArrowDown size={16} strokeWidth={2.5} />
  </a>
</div>

<style lang="scss">
  /* // TODO move to global styles */
  a.rounded-button {
    display: inline-block;
    padding: 6px;
    border-radius: 50%;
    background-color: var(--bg-additive-light);
    color: var(--color-white);
    text-decoration: none;
    margin-top: -4px;
    line-height: 0;
  }
</style>
